package services

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"math"
	"net/http"
	"sync"

	"github.com/zmb3/spotify/v2"
)

// TODO: correct BPM calculation
type SpotifyPlaylistResponse struct {
    ID          string `json:"id"`
    Name        string `json:"name"`
    Description string `json:"description"`
    Public      bool   `json:"public"`
    // Add other fields as necessary
}

type RecommendationResponse struct {
	Tracks []struct {
		ID    string `json:"id"`
		Name  string `json:"name"`
		Artists []struct {
			Name string `json:"name"`
		} `json:"artists"`
		ExternalURLs struct {
			Spotify string `json:"spotify"`
		} `json:"external_urls"`
	} `json:"tracks"`
}

type PlaylistService struct {
	spotifyService SpotifyService
}

func NewPlaylistService(spotifyService SpotifyService) *PlaylistService {
	return &PlaylistService{
		spotifyService: spotifyService,
	}
}

type TrackWithBPM struct {
	Track spotify.SimpleTrack
	BPM   float32
}

// CreatePlaylist generates a Spotify playlist based on the user's input
func CreatePlaylist(accessToken, paceUnit string, paceInSeconds int, gender string, height float64, heightUnit string) (string, error) {
	// Convert height to centimeters if needed
	if heightUnit == "in" {
		height = height * 2.54
	}

	// Calculate the desired BPM based on pace and height
	//pacePerKm := float64(paceInSeconds) / 60.0
	//bpm := int(180.0 / pacePerKm)

	// Call Spotify API to create a playlist
	playlistID, err := createSpotifyPlaylist(accessToken)
	if err != nil {
		return "", err
	}

	// Get a seed song
	//seed_song, err:= get_song(accessToken, "pop", bpm)

	// Return the Spotify playlist link
	return fmt.Sprintf("https://open.spotify.com/playlist/%s", playlistID), nil
}

// Helper function to interact with the Spotify API
func createSpotifyPlaylist(accessToken string) (string, error) {
    url := "https://api.spotify.com/v1/me/playlists"

    playlistData := map[string]interface{}{
        "name":        "Beatpace Running Playlist",
        "description": "A playlist generated by Beatpace to match your running pace",
        "public":      false,
    }

    jsonData, err := json.Marshal(playlistData)
    if err != nil {
        return "", fmt.Errorf("failed to marshal playlist data: %w", err)
    }

    req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
    if err != nil {
        return "", fmt.Errorf("failed to create request: %w", err)
    }

    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer "+accessToken)

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return "", fmt.Errorf("failed to send request: %w", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusCreated {
        return "", fmt.Errorf("failed to create playlist, status code: %d", resp.StatusCode)
    }

    var playlistResponse SpotifyPlaylistResponse
    if err := json.NewDecoder(resp.Body).Decode(&playlistResponse); err != nil {
        return "", fmt.Errorf("failed to parse response JSON: %w", err)
    }

    return playlistResponse.ID, nil
}

func get_song(accessToken, seed_genre string, bpm int) (string, error){
	url := fmt.Sprintf(
		"https://api.spotify.com/v1/recommendations?seed_genres=%s&target_tempo=%d", 
		seed_genre, bpm)

	req, err := http.NewRequest("GET", url, nil)
	
	if err != nil {
		return "", err
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("failed to get songs, status code: %d", resp.StatusCode)
	}

	var songsResponse RecommendationResponse
	err = json.NewDecoder(resp.Body).Decode(&songsResponse)

	if err != nil {
		return "", err
	}

	if len(songsResponse.Tracks) == 0 {
		return "", fmt.Errorf("no songs found")
	}

	return songsResponse.Tracks[0].ExternalURLs.Spotify, nil
}

// GeneratePlaylist creates a playlist based on the target BPM
func (s *PlaylistService) GeneratePlaylist(ctx context.Context, userID string, targetBPM int) (*spotify.FullPlaylist, error) {
	// Get user's top tracks and artists for better recommendations
	client := s.spotifyService.GetClient(ctx, userID)
	if client == nil {
		return nil, fmt.Errorf("failed to get spotify client")
	}

	// Get user's top tracks
	topTracks, err := client.CurrentUsersTopTracks(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get top tracks: %v", err)
	}

	// Get user's top artists
	topArtists, err := client.CurrentUsersTopArtists(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get top artists: %v", err)
	}

	// Create channels for concurrent track search
	tracksChan := make(chan TrackWithBPM, 100)
	errorsChan := make(chan error, 10)
	var wg sync.WaitGroup

	// Launch goroutines to search for tracks with similar BPM
	// We'll use different seed combinations to get diverse results
	for i := 0; i < len(topTracks.Tracks) && i < 5; i++ {
		wg.Add(1)
		go func(track spotify.FullTrack) {
			defer wg.Done()
			s.searchSimilarTracks(ctx, client, track.ID, targetBPM, tracksChan, errorsChan)
		}(topTracks.Tracks[i])
	}

	// Also search using top artists as seeds
	for i := 0; i < len(topArtists.Artists) && i < 5; i++ {
		wg.Add(1)
		go func(artist spotify.FullArtist) {
			defer wg.Done()
			s.searchSimilarTracksFromArtist(ctx, client, artist.ID, targetBPM, tracksChan, errorsChan)
		}(topArtists.Artists[i])
	}

	// Start a goroutine to close channels when all searches are done
	go func() {
		wg.Wait()
		close(tracksChan)
		close(errorsChan)
	}()

	// Collect tracks and filter duplicates
	trackMap := make(map[string]TrackWithBPM)
	for track := range tracksChan {
		// Only keep tracks within Â±3 BPM of target
		if math.Abs(float64(targetBPM)-float64(track.BPM)) <= 3 {
			trackMap[track.Track.ID.String()] = track
		}
	}

	// Check for errors
	for err := range errorsChan {
		if err != nil {
			return nil, fmt.Errorf("error during track search: %v", err)
		}
	}

	// Convert map to slice and limit to 25 tracks
	var selectedTracks []spotify.ID
	for _, track := range trackMap {
		selectedTracks = append(selectedTracks, track.Track.ID)
		if len(selectedTracks) >= 25 {
			break
		}
	}

	if len(selectedTracks) == 0 {
		return nil, fmt.Errorf("no suitable tracks found")
	}

	// Create a new playlist
	playlist, err := client.CreatePlaylistForUser(ctx, userID, fmt.Sprintf("BeatPace - %d BPM", targetBPM), "", false, false)
	if err != nil {
		return nil, fmt.Errorf("failed to create playlist: %v", err)
	}

	// Add tracks to the playlist
	_, err = client.AddTracksToPlaylist(ctx, playlist.ID, selectedTracks...)
	if err != nil {
		return nil, fmt.Errorf("failed to add tracks to playlist: %v", err)
	}

	return playlist, nil
}

func (s *PlaylistService) searchSimilarTracks(ctx context.Context, client *spotify.Client, seedTrack spotify.ID, targetBPM int, tracksChan chan<- TrackWithBPM, errorsChan chan<- error) {
	// Create recommendations request with seed track and target BPM
	attrs := spotify.NewTrackAttributes().TargetTempo(float64(targetBPM))

	seeds := spotify.Seeds{
		Tracks: []spotify.ID{seedTrack},
	}

	recommendations, err := client.GetRecommendations(ctx, seeds, attrs)
	if err != nil {
		errorsChan <- fmt.Errorf("failed to get recommendations: %v", err)
		return
	}

	// Get audio features for all tracks to check BPM
	var trackIDs []spotify.ID
	for _, track := range recommendations.Tracks {
		trackIDs = append(trackIDs, track.ID)
	}

	features, err := client.GetAudioFeatures(ctx, trackIDs...)
	if err != nil {
		errorsChan <- fmt.Errorf("failed to get audio features: %v", err)
		return
	}

	// Match features with tracks and send to channel
	for i, track := range recommendations.Tracks {
		if i < len(features) && features[i] != nil {
			tracksChan <- TrackWithBPM{
				Track: track,
				BPM:   features[i].Tempo,
			}
		}
	}
}

func (s *PlaylistService) searchSimilarTracksFromArtist(ctx context.Context, client *spotify.Client, artistID spotify.ID, targetBPM int, tracksChan chan<- TrackWithBPM, errorsChan chan<- error) {
	// Similar to searchSimilarTracks but using artist as seed
	attrs := spotify.NewTrackAttributes().TargetTempo(float64(targetBPM))

	seeds := spotify.Seeds{
		Artists: []spotify.ID{artistID},
	}

	recommendations, err := client.GetRecommendations(ctx, seeds, attrs)
	if err != nil {
		errorsChan <- fmt.Errorf("failed to get recommendations: %v", err)
		return
	}

	var trackIDs []spotify.ID
	for _, track := range recommendations.Tracks {
		trackIDs = append(trackIDs, track.ID)
	}

	features, err := client.GetAudioFeatures(ctx, trackIDs...)
	if err != nil {
		errorsChan <- fmt.Errorf("failed to get audio features: %v", err)
		return
	}

	for i, track := range recommendations.Tracks {
		if i < len(features) && features[i] != nil {
			tracksChan <- TrackWithBPM{
				Track: track,
				BPM:   features[i].Tempo,
			}
		}
	}
}